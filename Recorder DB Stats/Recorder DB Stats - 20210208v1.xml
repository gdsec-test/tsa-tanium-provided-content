<!-- Exported using version "7_4_3_1242" on Monday, February 08, 2021 4:55:45 PM -->
<content>
    <sensor>
        <name>Recorder DB Stats - Distribution</name>
        <what_hash>3855379847</what_hash>
        <category>Recorder</category>
        <description>Show the distribution of space, per event category, in the local recorder DB rounded to the nearest 5%.</description>
        <result_type>1</result_type>
        <qseconds>900</qseconds>
        <max_strings>200000</max_strings>
        <max_string_age_minutes>10080</max_string_age_minutes>
        <ignore_case_flag>1</ignore_case_flag>
        <delimiter>|</delimiter>
        <hidden_flag>0</hidden_flag>
        <queries>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>0</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    &quot;&quot;&quot;
    We can be guaranteed to have the dbstat virtual take, so this
    doesn&#x27;t take into accounts indexes, etc... Just the DatabaseStats
    Table managed by tanium
    &quot;&quot;&quot;
    query = &#x27;select * from DatabaseStats&#x27;

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    &quot;&quot;&quot; These are the keys we look at &quot;&quot;&quot;
    keys = [&quot;SignatureData&quot;, &quot;DNSEvents&quot;, &quot;HTTPEvents&quot;, &quot;SecurityEvents&quot;,
            &quot;ProcessEvents&quot;, &quot;FileEvents&quot;, &quot;LibraryEvents&quot;, &quot;NetworkEvents&quot;,
            &quot;RegistryEvents&quot;]
    datapoints = [&#x27;row_count&#x27;, &#x27;avg_row_size&#x27;,
                  &#x27;string_count&#x27;, &#x27;avg_string_size&#x27;]
    size_data = dict.fromkeys(keys)

    &quot;&quot;&quot; Let&#x27;s be efficient - one go through the data to fill our dict &quot;&quot;&quot;
    &quot;&quot;&quot; keys[Table][row_count]&#x2F;
                   [avg_row_size]&#x2F;
                   [string_count]&#x2F;
                   [avg_string_size] &quot;&quot;&quot;


    for line in response.splitlines():
        tid, obj, evt, ts = line.split(&quot;|&quot;)
        if obj in keys:
            if evt in datapoints:
                if size_data[obj] is None:
                    size_data[obj] = {}
                size_data[obj][evt] = ts

    &quot;&quot;&quot; Now calculate our total sizes &quot;&quot;&quot;
    total_size = 0
    table_size = dict.fromkeys(keys)
    for table in size_data:
        if size_data[table] is not None:
            table_size[table] = ( float(size_data[table][&#x27;row_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_row_size&#x27;])) + \
                                ( float(size_data[table][&#x27;string_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_string_size&#x27;]))

            total_size += table_size[table]

    &quot;&quot;&quot; Now let&#x27;s figure out our output &quot;&quot;&quot;
    percentages = dict.fromkeys(keys)
    base = 5
    for table in percentages:
        if table_size[table] is not None and total_size != 0:
            percent = table_size[table] &#x2F; total_size * 100
            scaled =  int(base * round(float(percent)&#x2F;base))
            percentages[table] = str(scaled)
        else:
            precentages[table] = &#x27;-&#x27;

    msg = &#x27;|&#x27;.join([percentages[&#x27;ProcessEvents&#x27;], percentages[&#x27;FileEvents&#x27;],
                    percentages[&#x27;NetworkEvents&#x27;], percentages[&#x27;RegistryEvents&#x27;],
                    percentages[&#x27;SecurityEvents&#x27;], percentages[&#x27;DNSEvents&#x27;],
                    percentages[&#x27;LibraryEvents&#x27;], percentages[&#x27;SignatureData&#x27;],
                    percentages[&#x27;HTTPEvents&#x27;]])
    tanium.results.add(msg)


if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>1</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    &quot;&quot;&quot;
    We can be guaranteed to have the dbstat virtual take, so this
    doesn&#x27;t take into accounts indexes, etc... Just the DatabaseStats
    Table managed by tanium
    &quot;&quot;&quot;
    query = &#x27;select * from DatabaseStats&#x27;

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    &quot;&quot;&quot; These are the keys we look at &quot;&quot;&quot;
    keys = [&quot;SignatureData&quot;, &quot;DNSEvents&quot;, &quot;HTTPEvents&quot;, &quot;SecurityEvents&quot;,
            &quot;ProcessEvents&quot;, &quot;FileEvents&quot;, &quot;LibraryEvents&quot;, &quot;NetworkEvents&quot;,
            &quot;RegistryEvents&quot;]
    datapoints = [&#x27;row_count&#x27;, &#x27;avg_row_size&#x27;,
                  &#x27;string_count&#x27;, &#x27;avg_string_size&#x27;]
    size_data = dict.fromkeys(keys)

    &quot;&quot;&quot; Let&#x27;s be efficient - one go through the data to fill our dict &quot;&quot;&quot;
    &quot;&quot;&quot; keys[Table][row_count]&#x2F;
                   [avg_row_size]&#x2F;
                   [string_count]&#x2F;
                   [avg_string_size] &quot;&quot;&quot;


    for line in response.splitlines():
        tid, obj, evt, ts = line.split(&quot;|&quot;)
        if obj in keys:
            if evt in datapoints:
                if size_data[obj] is None:
                    size_data[obj] = {}
                size_data[obj][evt] = ts

    &quot;&quot;&quot; Now calculate our total sizes &quot;&quot;&quot;
    total_size = 0
    table_size = dict.fromkeys(keys)
    for table in size_data:
        if size_data[table] is not None:
            table_size[table] = ( float(size_data[table][&#x27;row_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_row_size&#x27;])) + \
                                ( float(size_data[table][&#x27;string_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_string_size&#x27;]))

            total_size += table_size[table]

    &quot;&quot;&quot; Now let&#x27;s figure out our output &quot;&quot;&quot;
    percentages = dict.fromkeys(keys)
    base = 5
    for table in percentages:
        if table_size[table] is not None and total_size != 0:
            percent = table_size[table] &#x2F; total_size * 100
            scaled =  int(base * round(float(percent)&#x2F;base))
            percentages[table] = str(scaled)
        else:
            precentages[table] = &#x27;-&#x27;

    msg = &#x27;|&#x27;.join([percentages[&#x27;ProcessEvents&#x27;], percentages[&#x27;FileEvents&#x27;],
                    percentages[&#x27;NetworkEvents&#x27;], percentages[&#x27;RegistryEvents&#x27;],
                    percentages[&#x27;SecurityEvents&#x27;], percentages[&#x27;DNSEvents&#x27;],
                    percentages[&#x27;LibraryEvents&#x27;], percentages[&#x27;SignatureData&#x27;],
                    percentages[&#x27;HTTPEvents&#x27;]])
    tanium.results.add(msg)


if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>2</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    &quot;&quot;&quot;
    We can be guaranteed to have the dbstat virtual take, so this
    doesn&#x27;t take into accounts indexes, etc... Just the DatabaseStats
    Table managed by tanium
    &quot;&quot;&quot;
    query = &#x27;select * from DatabaseStats&#x27;

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    &quot;&quot;&quot; These are the keys we look at &quot;&quot;&quot;
    keys = [&quot;SignatureData&quot;, &quot;DNSEvents&quot;, &quot;HTTPEvents&quot;, &quot;SecurityEvents&quot;,
            &quot;ProcessEvents&quot;, &quot;FileEvents&quot;, &quot;LibraryEvents&quot;, &quot;NetworkEvents&quot;,
            &quot;RegistryEvents&quot;]
    datapoints = [&#x27;row_count&#x27;, &#x27;avg_row_size&#x27;,
                  &#x27;string_count&#x27;, &#x27;avg_string_size&#x27;]
    size_data = dict.fromkeys(keys)

    &quot;&quot;&quot; Let&#x27;s be efficient - one go through the data to fill our dict &quot;&quot;&quot;
    &quot;&quot;&quot; keys[Table][row_count]&#x2F;
                   [avg_row_size]&#x2F;
                   [string_count]&#x2F;
                   [avg_string_size] &quot;&quot;&quot;


    for line in response.splitlines():
        tid, obj, evt, ts = line.split(&quot;|&quot;)
        if obj in keys:
            if evt in datapoints:
                if size_data[obj] is None:
                    size_data[obj] = {}
                size_data[obj][evt] = ts

    &quot;&quot;&quot; Now calculate our total sizes &quot;&quot;&quot;
    total_size = 0
    table_size = dict.fromkeys(keys)
    for table in size_data:
        if size_data[table] is not None:
            table_size[table] = ( float(size_data[table][&#x27;row_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_row_size&#x27;])) + \
                                ( float(size_data[table][&#x27;string_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_string_size&#x27;]))

            total_size += table_size[table]

    &quot;&quot;&quot; Now let&#x27;s figure out our output &quot;&quot;&quot;
    percentages = dict.fromkeys(keys)
    base = 5
    for table in percentages:
        if table_size[table] is not None and total_size != 0:
            percent = table_size[table] &#x2F; total_size * 100
            scaled =  int(base * round(float(percent)&#x2F;base))
            percentages[table] = str(scaled)
        else:
            precentages[table] = &#x27;-&#x27;

    msg = &#x27;|&#x27;.join([percentages[&#x27;ProcessEvents&#x27;], percentages[&#x27;FileEvents&#x27;],
                    percentages[&#x27;NetworkEvents&#x27;], percentages[&#x27;RegistryEvents&#x27;],
                    percentages[&#x27;SecurityEvents&#x27;], percentages[&#x27;DNSEvents&#x27;],
                    percentages[&#x27;LibraryEvents&#x27;], percentages[&#x27;SignatureData&#x27;],
                    percentages[&#x27;HTTPEvents&#x27;]])
    tanium.results.add(msg)


if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
        </queries>
        <columns>
            <column>
                <column_index>0</column_index>
                <name>Process Events</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>1</column_index>
                <name>File Events</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>2</column_index>
                <name>Network Events</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>3</column_index>
                <name>Registry Events</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>4</column_index>
                <name>Security Events</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>5</column_index>
                <name>DNS Events</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>6</column_index>
                <name>Library Events</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>7</column_index>
                <name>Signature Data</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>8</column_index>
                <name>HTTP Events</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
        </columns>
        <meta_data/>
        <content_set>
            <name>Tanium Recorder</name>
            <description>Content which interacts with the Tanium Recorder</description>
            <reserved_name>tanium-recorder</reserved_name>
            <meta_data/>
        </content_set>
    </sensor>
    <sensor>
        <name>Recorder DB Stats - Event Rank</name>
        <what_hash>2868926811</what_hash>
        <category>Recorder</category>
        <description>Report the size of each local recorder database, by category size, as a rank. 1 being the largest category, 2 the next largest, and so on.</description>
        <result_type>1</result_type>
        <qseconds>900</qseconds>
        <max_strings>200000</max_strings>
        <max_string_age_minutes>10080</max_string_age_minutes>
        <ignore_case_flag>1</ignore_case_flag>
        <delimiter>|</delimiter>
        <hidden_flag>0</hidden_flag>
        <queries>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>0</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;
&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox


def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    &quot;&quot;&quot;
    We can&#x27;t be guaranteed to have the dbstat virtual take, so this
    doesn&#x27;t take into accounts indexes, etc... Just the DatabaseStats
    Table managed by tanium
    &quot;&quot;&quot;
    query = &#x27;select * from DatabaseStats&#x27;

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    &quot;&quot;&quot; These are the keys we look at &quot;&quot;&quot;
    keys = [&quot;SignatureData&quot;, &quot;DNSEvents&quot;, &quot;HTTPEvents&quot;, &quot;SecurityEvents&quot;,
            &quot;ProcessEvents&quot;, &quot;FileEvents&quot;, &quot;LibraryEvents&quot;, &quot;NetworkEvents&quot;,
            &quot;RegistryEvents&quot;]
    datapoints = [&#x27;row_count&#x27;, &#x27;avg_row_size&#x27;,
                  &#x27;string_count&#x27;, &#x27;avg_string_size&#x27;]
    size_data = dict.fromkeys(keys)

    &quot;&quot;&quot; Let&#x27;s be efficient - one go through the data to fill our dict &quot;&quot;&quot;
    &quot;&quot;&quot; keys[Table][row_count]&#x2F;
                   [avg_row_size]&#x2F;
                   [string_count]&#x2F;
                   [avg_string_size] &quot;&quot;&quot;


    for line in response.splitlines():
        tid, obj, evt, ts = line.split(&quot;|&quot;)
        if obj in keys:
            if evt in datapoints:
                if size_data[obj] is None:
                    size_data[obj] = {}
                size_data[obj][evt] = ts

    &quot;&quot;&quot; Now calculate our total sizes &quot;&quot;&quot;
    total_size = 0
    table_size = dict.fromkeys(keys)
    for table in size_data:
        if size_data[table] is not None:
            table_size[table] = ( float(size_data[table][&#x27;row_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_row_size&#x27;])) + \
                                ( float(size_data[table][&#x27;string_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_string_size&#x27;]))

            total_size += table_size[table]

    &quot;&quot;&quot; Now let&#x27;s figure out our output &quot;&quot;&quot;
    percentages = dict.fromkeys(keys)
    base = 5
    for table in percentages:
        if table_size[table] is not None and total_size != 0:
            percent = table_size[table] &#x2F; total_size * 100
            percentages[table] = percent

    count = 1
    for table in sorted(percentages, key=percentages.get, reverse=True):
        msg = &#x27;|&#x27;.join([str(count),str(table)])
        tanium.results.add(msg)
        count += 1

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>1</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;
&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox


def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    &quot;&quot;&quot;
    We can&#x27;t be guaranteed to have the dbstat virtual take, so this
    doesn&#x27;t take into accounts indexes, etc... Just the DatabaseStats
    Table managed by tanium
    &quot;&quot;&quot;
    query = &#x27;select * from DatabaseStats&#x27;

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    &quot;&quot;&quot; These are the keys we look at &quot;&quot;&quot;
    keys = [&quot;SignatureData&quot;, &quot;DNSEvents&quot;, &quot;HTTPEvents&quot;, &quot;SecurityEvents&quot;,
            &quot;ProcessEvents&quot;, &quot;FileEvents&quot;, &quot;LibraryEvents&quot;, &quot;NetworkEvents&quot;,
            &quot;RegistryEvents&quot;]
    datapoints = [&#x27;row_count&#x27;, &#x27;avg_row_size&#x27;,
                  &#x27;string_count&#x27;, &#x27;avg_string_size&#x27;]
    size_data = dict.fromkeys(keys)

    &quot;&quot;&quot; Let&#x27;s be efficient - one go through the data to fill our dict &quot;&quot;&quot;
    &quot;&quot;&quot; keys[Table][row_count]&#x2F;
                   [avg_row_size]&#x2F;
                   [string_count]&#x2F;
                   [avg_string_size] &quot;&quot;&quot;


    for line in response.splitlines():
        tid, obj, evt, ts = line.split(&quot;|&quot;)
        if obj in keys:
            if evt in datapoints:
                if size_data[obj] is None:
                    size_data[obj] = {}
                size_data[obj][evt] = ts

    &quot;&quot;&quot; Now calculate our total sizes &quot;&quot;&quot;
    total_size = 0
    table_size = dict.fromkeys(keys)
    for table in size_data:
        if size_data[table] is not None:
            table_size[table] = ( float(size_data[table][&#x27;row_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_row_size&#x27;])) + \
                                ( float(size_data[table][&#x27;string_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_string_size&#x27;]))

            total_size += table_size[table]

    &quot;&quot;&quot; Now let&#x27;s figure out our output &quot;&quot;&quot;
    percentages = dict.fromkeys(keys)
    base = 5
    for table in percentages:
        if table_size[table] is not None and total_size != 0:
            percent = table_size[table] &#x2F; total_size * 100
            percentages[table] = percent

    count = 1
    for table in sorted(percentages, key=percentages.get, reverse=True):
        msg = &#x27;|&#x27;.join([str(count),str(table)])
        tanium.results.add(msg)
        count += 1

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>2</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;
&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox


def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    &quot;&quot;&quot;
    We can&#x27;t be guaranteed to have the dbstat virtual take, so this
    doesn&#x27;t take into accounts indexes, etc... Just the DatabaseStats
    Table managed by tanium
    &quot;&quot;&quot;
    query = &#x27;select * from DatabaseStats&#x27;

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    &quot;&quot;&quot; These are the keys we look at &quot;&quot;&quot;
    keys = [&quot;SignatureData&quot;, &quot;DNSEvents&quot;, &quot;HTTPEvents&quot;, &quot;SecurityEvents&quot;,
            &quot;ProcessEvents&quot;, &quot;FileEvents&quot;, &quot;LibraryEvents&quot;, &quot;NetworkEvents&quot;,
            &quot;RegistryEvents&quot;]
    datapoints = [&#x27;row_count&#x27;, &#x27;avg_row_size&#x27;,
                  &#x27;string_count&#x27;, &#x27;avg_string_size&#x27;]
    size_data = dict.fromkeys(keys)

    &quot;&quot;&quot; Let&#x27;s be efficient - one go through the data to fill our dict &quot;&quot;&quot;
    &quot;&quot;&quot; keys[Table][row_count]&#x2F;
                   [avg_row_size]&#x2F;
                   [string_count]&#x2F;
                   [avg_string_size] &quot;&quot;&quot;


    for line in response.splitlines():
        tid, obj, evt, ts = line.split(&quot;|&quot;)
        if obj in keys:
            if evt in datapoints:
                if size_data[obj] is None:
                    size_data[obj] = {}
                size_data[obj][evt] = ts

    &quot;&quot;&quot; Now calculate our total sizes &quot;&quot;&quot;
    total_size = 0
    table_size = dict.fromkeys(keys)
    for table in size_data:
        if size_data[table] is not None:
            table_size[table] = ( float(size_data[table][&#x27;row_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_row_size&#x27;])) + \
                                ( float(size_data[table][&#x27;string_count&#x27;]) * \
                                  float(size_data[table][&#x27;avg_string_size&#x27;]))

            total_size += table_size[table]

    &quot;&quot;&quot; Now let&#x27;s figure out our output &quot;&quot;&quot;
    percentages = dict.fromkeys(keys)
    base = 5
    for table in percentages:
        if table_size[table] is not None and total_size != 0:
            percent = table_size[table] &#x2F; total_size * 100
            percentages[table] = percent

    count = 1
    for table in sorted(percentages, key=percentages.get, reverse=True):
        msg = &#x27;|&#x27;.join([str(count),str(table)])
        tanium.results.add(msg)
        count += 1

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
        </queries>
        <columns>
            <column>
                <column_index>0</column_index>
                <name>Rank</name>
                <hidden_flag>0</hidden_flag>
                <result_type>3</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>1</column_index>
                <name>Category</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
        </columns>
        <meta_data/>
        <content_set>
            <name>Tanium Recorder</name>
            <description>Content which interacts with the Tanium Recorder</description>
            <reserved_name>tanium-recorder</reserved_name>
            <meta_data/>
        </content_set>
    </sensor>
    <sensor>
        <name>Recorder DB Stats - File</name>
        <what_hash>1375575447</what_hash>
        <category>Recorder</category>
        <description>Analyze the most recent 10,000 file events and report back any events that take up more than 3% of that sample. Any events marked with a type of &quot;path&#x27; are the exact path in the DB. Any events marked with a type of &quot;dir&#x27; are a combination of all events in the same category under that directory.</description>
        <result_type>1</result_type>
        <qseconds>900</qseconds>
        <max_strings>200000</max_strings>
        <max_string_age_minutes>10080</max_string_age_minutes>
        <ignore_case_flag>1</ignore_case_flag>
        <delimiter>|</delimiter>
        <hidden_flag>0</hidden_flag>
        <queries>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>0</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys
import os

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    getlines = 10000
    percent = 1
    count_limit = getlines * float(float(percent) &#x2F; 100)

    &quot;&quot;&quot; Get First &lt;getlines&gt; lines &quot;&quot;&quot;
    query = &quot;&quot;&quot;select process_path, file, user_name, group_name
               from FileSummary limit {}&quot;&quot;&quot;.format(getlines)


    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    mymap = {}
    for line in response.splitlines():
        line = line.encode(&#x27;ascii&#x27;, errors=&#x27;backslashreplace&#x27;).decode()
        (proc,file,user,group) = line.split(&quot;|&quot;)
        newline = &#x27;|&#x27;.join([proc, &quot;file&quot;, file, user, group])
        if newline in mymap:
            mymap[newline] += 1
        else:
            mymap[newline] = 1
        itemCount = {}
        (head, tail) = os.path.split(file)
        while tail:
            newline = &#x27;|&#x27;.join([proc, &quot;dir&quot;, head,user,group])
            if newline in mymap:
                mymap[newline] += 1
            else:
                if head != &#x27;&#x27;:
                    mymap[newline] = 1
            (head, tail) = os.path.split(head)
    for i in mymap:
        if mymap[i] &gt; count_limit:
          tanium.results.add(&quot;{}&quot;.format(i))


if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>1</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys
import os

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    getlines = 10000
    percent = 1
    count_limit = getlines * float(float(percent) &#x2F; 100)

    &quot;&quot;&quot; Get First &lt;getlines&gt; lines &quot;&quot;&quot;
    query = &quot;&quot;&quot;select process_path, file, user_name, group_name
               from FileSummary limit {}&quot;&quot;&quot;.format(getlines)


    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    mymap = {}
    for line in response.splitlines():
        line = line.encode(&#x27;ascii&#x27;, errors=&#x27;backslashreplace&#x27;).decode()
        (proc,file,user,group) = line.split(&quot;|&quot;)
        newline = &#x27;|&#x27;.join([proc, &quot;file&quot;, file, user, group])
        if newline in mymap:
            mymap[newline] += 1
        else:
            mymap[newline] = 1
        itemCount = {}
        (head, tail) = os.path.split(file)
        while tail:
            newline = &#x27;|&#x27;.join([proc, &quot;dir&quot;, head,user,group])
            if newline in mymap:
                mymap[newline] += 1
            else:
                if head != &#x27;&#x27;:
                    mymap[newline] = 1
            (head, tail) = os.path.split(head)
    for i in mymap:
        if mymap[i] &gt; count_limit:
          tanium.results.add(&quot;{}&quot;.format(i))


if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>2</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys
import os

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    getlines = 10000
    percent = 1
    count_limit = getlines * float(float(percent) &#x2F; 100)

    &quot;&quot;&quot; Get First &lt;getlines&gt; lines &quot;&quot;&quot;
    query = &quot;&quot;&quot;select process_path, file, user_name, group_name
               from FileSummary limit {}&quot;&quot;&quot;.format(getlines)


    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    mymap = {}
    for line in response.splitlines():
        line = line.encode(&#x27;ascii&#x27;, errors=&#x27;backslashreplace&#x27;).decode()
        (proc,file,user,group) = line.split(&quot;|&quot;)
        newline = &#x27;|&#x27;.join([proc, &quot;file&quot;, file, user, group])
        if newline in mymap:
            mymap[newline] += 1
        else:
            mymap[newline] = 1
        itemCount = {}
        (head, tail) = os.path.split(file)
        while tail:
            newline = &#x27;|&#x27;.join([proc, &quot;dir&quot;, head,user,group])
            if newline in mymap:
                mymap[newline] += 1
            else:
                if head != &#x27;&#x27;:
                    mymap[newline] = 1
            (head, tail) = os.path.split(head)
    for i in mymap:
        if mymap[i] &gt; count_limit:
          tanium.results.add(&quot;{}&quot;.format(i))


if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
        </queries>
        <columns>
            <column>
                <column_index>0</column_index>
                <name>Process Path</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>1</column_index>
                <name>Type</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>2</column_index>
                <name>File Path</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>3</column_index>
                <name>User</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>4</column_index>
                <name>Group</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
        </columns>
        <meta_data/>
        <content_set>
            <name>Tanium Recorder</name>
            <description>Content which interacts with the Tanium Recorder</description>
            <reserved_name>tanium-recorder</reserved_name>
            <meta_data/>
        </content_set>
    </sensor>
    <sensor>
        <name>Recorder DB Stats - Network</name>
        <what_hash>3934259633</what_hash>
        <category>Recorder</category>
        <description>Analyze the most recent 10,000 network events and report back any events that take up more than 3% of that sample.</description>
        <result_type>1</result_type>
        <qseconds>900</qseconds>
        <max_strings>200000</max_strings>
        <max_string_age_minutes>10080</max_string_age_minutes>
        <ignore_case_flag>1</ignore_case_flag>
        <delimiter>|</delimiter>
        <hidden_flag>0</hidden_flag>
        <queries>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>0</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys
import os

import tanium
from tanium_recorder.tanium_cx.core import mailbox as recorder_mailbox

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = recorder_mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    getlines = 10000
    percent = 3
    count_limit = getlines * float(float(percent) &#x2F; 100)

    &quot;&quot;&quot; Get First &lt;getlines&gt; lines &quot;&quot;&quot;
    query = &quot;&quot;&quot;select process_path, local_address, local_address_port,
               remote_address, remote_address_port, operation,
               user_name, group_name
               from NetworkSummary limit {}&quot;&quot;&quot;.format(getlines)


    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    mymap = {}
    for line in response.splitlines():
        line = line.encode(&#x27;ascii&#x27;, errors=&#x27;backslashreplace&#x27;).decode()
        (proc, lad, ladp, rad, radp, op, user, group) = line.split(&quot;|&quot;)
        if op == &#x27;Accept&#x27; or op == &#x27;Connect&#x27;:
            newline_a = &#x27;|&#x27;.join([proc, op, &#x27;-&#x27;, rad, radp, user, group])
            if newline_a in mymap:
                mymap[newline_a] += 1
            else:
                mymap[newline_a] = 1
            newline_b = &#x27;|&#x27;.join([proc, op, ladp, rad, &#x27;-&#x27;, user, group])
            if newline_b in mymap and int(ladp) != 0:
                mymap[newline_b] += 1
            else:
                mymap[newline_b] = 1
        elif op == &#x27;Disconnect&#x27;:
            &quot;&quot;&quot; Add only if there is an associated Connect&#x2F;Accept &quot;&quot;&quot;
            mm = []
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Accept&#x27;, &#x27;-&#x27;, rad, radp, user, group]))
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Accept&#x27;, ladp, rad, &#x27;-&#x27;, user, group]))
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Connect&#x27;, &#x27;-&#x27;, rad, radp, user, group]))
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Connect&#x27;, ladp, rad, &#x27;-&#x27;, user, group]))
            for i in mm:
                if i in mymap:
                    mymap[i] += 1


    for i in mymap:
        if mymap[i] &gt; count_limit:
            tanium.results.add(&quot;{}&quot;.format(i))

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>1</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys
import os

import tanium
from tanium_recorder.tanium_cx.core import mailbox as recorder_mailbox

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = recorder_mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    getlines = 10000
    percent = 3
    count_limit = getlines * float(float(percent) &#x2F; 100)

    &quot;&quot;&quot; Get First &lt;getlines&gt; lines &quot;&quot;&quot;
    query = &quot;&quot;&quot;select process_path, local_address, local_address_port,
               remote_address, remote_address_port, operation,
               user_name, group_name
               from NetworkSummary limit {}&quot;&quot;&quot;.format(getlines)


    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    mymap = {}
    for line in response.splitlines():
        line = line.encode(&#x27;ascii&#x27;, errors=&#x27;backslashreplace&#x27;).decode()
        (proc, lad, ladp, rad, radp, op, user, group) = line.split(&quot;|&quot;)
        if op == &#x27;Accept&#x27; or op == &#x27;Connect&#x27;:
            newline_a = &#x27;|&#x27;.join([proc, op, &#x27;-&#x27;, rad, radp, user, group])
            if newline_a in mymap:
                mymap[newline_a] += 1
            else:
                mymap[newline_a] = 1
            newline_b = &#x27;|&#x27;.join([proc, op, ladp, rad, &#x27;-&#x27;, user, group])
            if newline_b in mymap and int(ladp) != 0:
                mymap[newline_b] += 1
            else:
                mymap[newline_b] = 1
        elif op == &#x27;Disconnect&#x27;:
            &quot;&quot;&quot; Add only if there is an associated Connect&#x2F;Accept &quot;&quot;&quot;
            mm = []
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Accept&#x27;, &#x27;-&#x27;, rad, radp, user, group]))
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Accept&#x27;, ladp, rad, &#x27;-&#x27;, user, group]))
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Connect&#x27;, &#x27;-&#x27;, rad, radp, user, group]))
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Connect&#x27;, ladp, rad, &#x27;-&#x27;, user, group]))
            for i in mm:
                if i in mymap:
                    mymap[i] += 1


    for i in mymap:
        if mymap[i] &gt; count_limit:
            tanium.results.add(&quot;{}&quot;.format(i))

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>2</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys
import os

import tanium
from tanium_recorder.tanium_cx.core import mailbox as recorder_mailbox

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = recorder_mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    getlines = 10000
    percent = 3
    count_limit = getlines * float(float(percent) &#x2F; 100)

    &quot;&quot;&quot; Get First &lt;getlines&gt; lines &quot;&quot;&quot;
    query = &quot;&quot;&quot;select process_path, local_address, local_address_port,
               remote_address, remote_address_port, operation,
               user_name, group_name
               from NetworkSummary limit {}&quot;&quot;&quot;.format(getlines)


    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    mymap = {}
    for line in response.splitlines():
        line = line.encode(&#x27;ascii&#x27;, errors=&#x27;backslashreplace&#x27;).decode()
        (proc, lad, ladp, rad, radp, op, user, group) = line.split(&quot;|&quot;)
        if op == &#x27;Accept&#x27; or op == &#x27;Connect&#x27;:
            newline_a = &#x27;|&#x27;.join([proc, op, &#x27;-&#x27;, rad, radp, user, group])
            if newline_a in mymap:
                mymap[newline_a] += 1
            else:
                mymap[newline_a] = 1
            newline_b = &#x27;|&#x27;.join([proc, op, ladp, rad, &#x27;-&#x27;, user, group])
            if newline_b in mymap and int(ladp) != 0:
                mymap[newline_b] += 1
            else:
                mymap[newline_b] = 1
        elif op == &#x27;Disconnect&#x27;:
            &quot;&quot;&quot; Add only if there is an associated Connect&#x2F;Accept &quot;&quot;&quot;
            mm = []
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Accept&#x27;, &#x27;-&#x27;, rad, radp, user, group]))
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Accept&#x27;, ladp, rad, &#x27;-&#x27;, user, group]))
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Connect&#x27;, &#x27;-&#x27;, rad, radp, user, group]))
            mm.append(&#x27;|&#x27;.join([proc, &#x27;Connect&#x27;, ladp, rad, &#x27;-&#x27;, user, group]))
            for i in mm:
                if i in mymap:
                    mymap[i] += 1


    for i in mymap:
        if mymap[i] &gt; count_limit:
            tanium.results.add(&quot;{}&quot;.format(i))

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
        </queries>
        <columns>
            <column>
                <column_index>0</column_index>
                <name>Process Path</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>1</column_index>
                <name>Operation</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>2</column_index>
                <name>Local Port</name>
                <hidden_flag>0</hidden_flag>
                <result_type>3</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>3</column_index>
                <name>Remote Address</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>4</column_index>
                <name>Remote Port</name>
                <hidden_flag>0</hidden_flag>
                <result_type>3</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>5</column_index>
                <name>User</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>6</column_index>
                <name>Group</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
        </columns>
        <meta_data/>
        <content_set>
            <name>Tanium Recorder</name>
            <description>Content which interacts with the Tanium Recorder</description>
            <reserved_name>tanium-recorder</reserved_name>
            <meta_data/>
        </content_set>
    </sensor>
    <sensor>
        <name>Recorder DB Stats - Overview</name>
        <what_hash>227773046</what_hash>
        <category>Recorder</category>
        <description>Report days since last record, days since oldest recorder, and max DB size from the local recorder database.</description>
        <result_type>1</result_type>
        <qseconds>900</qseconds>
        <max_strings>200000</max_strings>
        <max_string_age_minutes>10080</max_string_age_minutes>
        <ignore_case_flag>1</ignore_case_flag>
        <delimiter>|</delimiter>
        <hidden_flag>0</hidden_flag>
        <queries>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>0</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import datetime
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

&quot;&quot;&quot; Scaling Function &quot;&quot;&quot;
def scale(num):
    nl = len(str(int(num)))
    roundto = float(10 ** (nl - 2))
    ans = round(int(num) &#x2F; roundto) * roundto
    return int(ans)

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    query = &#x27;select * from DatabaseStats&#x27;

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    categories = {}
    maxsize = &#x27;-&#x27;
    usedsize = &#x27;-&#x27;
    oldest = &#x27;-&#x27;
    newest = &#x27;-&#x27;
    now = datetime.datetime.utcnow()
    for line in response.splitlines():
        tid, obj, evt, ts = line.split(&quot;|&quot;)
        if obj == &quot;Global&quot;:
            if evt == &quot;database_file_size&quot;:
                maxsize = int(ts) &#x2F; 1024 &#x2F; 1024
            if evt == &quot;database_used_size&quot;:
                usedsize = int(ts) &#x2F; 1024 &#x2F; 1024
            if evt == &quot;newest_timestamp&quot;:
                if ts != &#x27;0&#x27;:
                    tsstamp = datetime.datetime.utcfromtimestamp(int(ts)&#x2F;1000)
                    if tsstamp &gt; now:
                        newest = &#x27;Err:{}&gt;{}&#x27;.format(ts, now)
                    else:
                        tdiff = now - tsstamp
                        dt = tdiff.days
                        if int(dt) &lt; 0:
                            newest = &#x27;Err:{}&gt;{} ({})&#x27;.format(ts, now, dt)
                        else:
                            newest = dt
            if evt == &quot;oldest_timestamp&quot;:
                if ts != &#x27;0&#x27;:
                    tsstamp = datetime.datetime.utcfromtimestamp(int(ts)&#x2F;1000)
                    if tsstamp &gt; now:
                        oldest = &#x27;Err:{}&gt;{}&#x27;.format(ts, now)
                    else:
                        tdiff = now - tsstamp
                        dt = tdiff.days
                        if int(dt) &lt; 0:
                            oldest = &#x27;Err:{}&gt;{} ({})&#x27;.format(ts, now, dt)
                        else:
                            oldest = dt

    msg = &#x27;|&#x27;.join([str(newest), str(oldest), str(scale(maxsize))]) + &#x27;\n&#x27;
    tanium.results.add(msg)

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>1</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import datetime
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

&quot;&quot;&quot; Scaling Function &quot;&quot;&quot;
def scale(num):
    nl = len(str(int(num)))
    roundto = float(10 ** (nl - 2))
    ans = round(int(num) &#x2F; roundto) * roundto
    return int(ans)

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    query = &#x27;select * from DatabaseStats&#x27;

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    categories = {}
    maxsize = &#x27;-&#x27;
    usedsize = &#x27;-&#x27;
    oldest = &#x27;-&#x27;
    newest = &#x27;-&#x27;
    now = datetime.datetime.utcnow()
    for line in response.splitlines():
        tid, obj, evt, ts = line.split(&quot;|&quot;)
        if obj == &quot;Global&quot;:
            if evt == &quot;database_file_size&quot;:
                maxsize = int(ts) &#x2F; 1024 &#x2F; 1024
            if evt == &quot;database_used_size&quot;:
                usedsize = int(ts) &#x2F; 1024 &#x2F; 1024
            if evt == &quot;newest_timestamp&quot;:
                if ts != &#x27;0&#x27;:
                    tsstamp = datetime.datetime.utcfromtimestamp(int(ts)&#x2F;1000)
                    if tsstamp &gt; now:
                        newest = &#x27;Err:{}&gt;{}&#x27;.format(ts, now)
                    else:
                        tdiff = now - tsstamp
                        dt = tdiff.days
                        if int(dt) &lt; 0:
                            newest = &#x27;Err:{}&gt;{} ({})&#x27;.format(ts, now, dt)
                        else:
                            newest = dt
            if evt == &quot;oldest_timestamp&quot;:
                if ts != &#x27;0&#x27;:
                    tsstamp = datetime.datetime.utcfromtimestamp(int(ts)&#x2F;1000)
                    if tsstamp &gt; now:
                        oldest = &#x27;Err:{}&gt;{}&#x27;.format(ts, now)
                    else:
                        tdiff = now - tsstamp
                        dt = tdiff.days
                        if int(dt) &lt; 0:
                            oldest = &#x27;Err:{}&gt;{} ({})&#x27;.format(ts, now, dt)
                        else:
                            oldest = dt

    msg = &#x27;|&#x27;.join([str(newest), str(oldest), str(scale(maxsize))]) + &#x27;\n&#x27;
    tanium.results.add(msg)

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>2</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import datetime
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

&quot;&quot;&quot; Scaling Function &quot;&quot;&quot;
def scale(num):
    nl = len(str(int(num)))
    roundto = float(10 ** (nl - 2))
    ans = round(int(num) &#x2F; roundto) * roundto
    return int(ans)

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    query = &#x27;select * from DatabaseStats&#x27;

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    categories = {}
    maxsize = &#x27;-&#x27;
    usedsize = &#x27;-&#x27;
    oldest = &#x27;-&#x27;
    newest = &#x27;-&#x27;
    now = datetime.datetime.utcnow()
    for line in response.splitlines():
        tid, obj, evt, ts = line.split(&quot;|&quot;)
        if obj == &quot;Global&quot;:
            if evt == &quot;database_file_size&quot;:
                maxsize = int(ts) &#x2F; 1024 &#x2F; 1024
            if evt == &quot;database_used_size&quot;:
                usedsize = int(ts) &#x2F; 1024 &#x2F; 1024
            if evt == &quot;newest_timestamp&quot;:
                if ts != &#x27;0&#x27;:
                    tsstamp = datetime.datetime.utcfromtimestamp(int(ts)&#x2F;1000)
                    if tsstamp &gt; now:
                        newest = &#x27;Err:{}&gt;{}&#x27;.format(ts, now)
                    else:
                        tdiff = now - tsstamp
                        dt = tdiff.days
                        if int(dt) &lt; 0:
                            newest = &#x27;Err:{}&gt;{} ({})&#x27;.format(ts, now, dt)
                        else:
                            newest = dt
            if evt == &quot;oldest_timestamp&quot;:
                if ts != &#x27;0&#x27;:
                    tsstamp = datetime.datetime.utcfromtimestamp(int(ts)&#x2F;1000)
                    if tsstamp &gt; now:
                        oldest = &#x27;Err:{}&gt;{}&#x27;.format(ts, now)
                    else:
                        tdiff = now - tsstamp
                        dt = tdiff.days
                        if int(dt) &lt; 0:
                            oldest = &#x27;Err:{}&gt;{} ({})&#x27;.format(ts, now, dt)
                        else:
                            oldest = dt

    msg = &#x27;|&#x27;.join([str(newest), str(oldest), str(scale(maxsize))]) + &#x27;\n&#x27;
    tanium.results.add(msg)

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
        </queries>
        <columns>
            <column>
                <column_index>0</column_index>
                <name>Newest Event (Days Back)</name>
                <hidden_flag>0</hidden_flag>
                <result_type>3</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>1</column_index>
                <name>Oldest Event (Days Back)</name>
                <hidden_flag>0</hidden_flag>
                <result_type>3</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>2</column_index>
                <name>Max DB Size</name>
                <hidden_flag>0</hidden_flag>
                <result_type>3</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
        </columns>
        <meta_data/>
        <content_set>
            <name>Tanium Recorder</name>
            <description>Content which interacts with the Tanium Recorder</description>
            <reserved_name>tanium-recorder</reserved_name>
            <meta_data/>
        </content_set>
    </sensor>
    <sensor>
        <name>Recorder DB Stats - Registry</name>
        <what_hash>2913153154</what_hash>
        <category>Recorder</category>
        <description>Analyze the most recent 10,000 registry events and report back any events that take up more than 3% of that sample. Any events marked with a type of &quot;key&#x27; are the exact key in the DB. Any events marked with a type of &quot;path&#x27; are a combination of all events in the same category under that key path.</description>
        <result_type>1</result_type>
        <qseconds>900</qseconds>
        <max_strings>200000</max_strings>
        <max_string_age_minutes>10080</max_string_age_minutes>
        <ignore_case_flag>1</ignore_case_flag>
        <delimiter>|</delimiter>
        <hidden_flag>0</hidden_flag>
        <queries>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>0</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys
import os

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder is disabled&quot;)
        return None

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    getlines = 10000
    percent = 3
    count_limit = getlines * float(float(percent) &#x2F; 100)

    &quot;&quot;&quot; Get first &lt;getlines&gt; lines &quot;&quot;&quot;
    query = &quot;&quot;&quot;select process_path,
               replace(replace(replace(key_path,&#x27;|&#x27;,&#x27;_PIPE_&#x27;),char(13),&#x27;_NEWLINE_&#x27;),char(10),&#x27;_NEWLINE_&#x27;),
               replace(replace(replace(value_name,&#x27;|&#x27;,&#x27;_PIPE_&#x27;),char(13),&#x27;_NEWLINE_&#x27;),char(10),&#x27;_NEWLINE_&#x27;),
               user_name, group_name
               from RegistrySummary limit {}&quot;&quot;&quot;.format(getlines)

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })

    mymap = {}
    for line in response.splitlines():
        line = line.encode(&#x27;ascii&#x27;, errors=&#x27;backslashreplace&#x27;).decode()
        (proc, key, val, user, group) = line.split(&quot;|&quot;)
        newline = &#x27;|&#x27;.join([proc, &quot;key&quot;, key, val, user, group])
        if newline in mymap:
            mymap[newline] += 1
        else:
            mymap[newline] = 1

        (head, tail) = os.path.split(key)
        while tail:
            newline = &#x27;|&#x27;.join([proc, &quot;path&quot;, head, val, user, group])
            if newline in mymap:
                mymap[newline] += 1
            else:
                if head != &#x27;&#x27;:
                    mymap[newline] = 1
            (head, tail) = os.path.split(head)
    for i in mymap:
        if mymap[i] &gt; count_limit:
            tanium.results.add(&quot;{}&quot;.format(i))


if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
        </queries>
        <columns>
            <column>
                <column_index>0</column_index>
                <name>Process Path</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>1</column_index>
                <name>Type</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>2</column_index>
                <name>Key</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>3</column_index>
                <name>Value Key</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>4</column_index>
                <name>User</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>5</column_index>
                <name>Group</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
        </columns>
        <meta_data/>
        <content_set>
            <name>Tanium Recorder</name>
            <description>Content which interacts with the Tanium Recorder</description>
            <reserved_name>tanium-recorder</reserved_name>
            <meta_data/>
        </content_set>
    </sensor>
    <sensor>
        <name>Recorder DB Status - Process</name>
        <what_hash>139615981</what_hash>
        <category>Recorder</category>
        <description>Analyze the 10,000 process events from the local recorder DB and report any process events that take up more than 3% of the sample size. In the command lines, any &#x27;|&#x27; is replaced with &#x27;_PIPE_&#x27; and any newline is replaced with &#x27;_NEWLINE_&#x27;.</description>
        <result_type>1</result_type>
        <qseconds>900</qseconds>
        <max_strings>200000</max_strings>
        <max_string_age_minutes>10080</max_string_age_minutes>
        <ignore_case_flag>1</ignore_case_flag>
        <delimiter>|</delimiter>
        <hidden_flag>0</hidden_flag>
        <queries>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>0</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder extension is disabled&quot;)
        return False

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    getlines = 10000
    percent = 3
    sql_count_limit = getlines * float(percent) &#x2F; 100

    &quot;&quot;&quot; Get first X lines, grouping them and showing ones over y% &quot;&quot;&quot;
    query = &quot;&quot;&quot;
select b.parent_path,
  replace(replace(replace(b.parent_command_line,&#x27;|&#x27;,&#x27;_PIPE_&#x27;),char(13),&#x27;_NEWLINE_&#x27;),char(10),&#x27;_NEWLINE_&#x27;),
  b.process_path,
  replace(replace(replace(b.process_command_line,&#x27;|&#x27;,&#x27;_PIPE_&#x27;),char(13),&#x27;_NEWLINE_&#x27;),char(10),&#x27;_NEWLINE_&#x27;),
  b.user_name, b.group_name
from
  (select count(*) as cnt, a.parent_path, a.parent_command_line,
     a.process_path, a.process_command_line, a.user_name, a.group_name
   from
     (select parent_path, parent_command_line,
        process_path, process_command_line, user_name, group_name
      from
        ProcessWithParentSummary limit {}
     ) as a
        group by a.parent_path, a.parent_command_line, a.process_path,
          a.process_command_line, a.user_name, a.group_name
        having cnt &gt; {}
        order by cnt
  ) as b&quot;&quot;&quot;.format(str(getlines), str(sql_count_limit))

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })


    for line in response.splitlines():
        line = line.encode(&#x27;ascii&#x27;, errors=&#x27;backslashreplace&#x27;).decode()
        tanium.results.add(&quot;{}&quot;.format(line))

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>1</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder extension is disabled&quot;)
        return False

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    getlines = 10000
    percent = 3
    sql_count_limit = getlines * float(percent) &#x2F; 100

    &quot;&quot;&quot; Get first X lines, grouping them and showing ones over y% &quot;&quot;&quot;
    query = &quot;&quot;&quot;
select b.parent_path,
  replace(replace(replace(b.parent_command_line,&#x27;|&#x27;,&#x27;_PIPE_&#x27;),char(13),&#x27;_NEWLINE_&#x27;),char(10),&#x27;_NEWLINE_&#x27;),
  b.process_path,
  replace(replace(replace(b.process_command_line,&#x27;|&#x27;,&#x27;_PIPE_&#x27;),char(13),&#x27;_NEWLINE_&#x27;),char(10),&#x27;_NEWLINE_&#x27;),
  b.user_name, b.group_name
from
  (select count(*) as cnt, a.parent_path, a.parent_command_line,
     a.process_path, a.process_command_line, a.user_name, a.group_name
   from
     (select parent_path, parent_command_line,
        process_path, process_command_line, user_name, group_name
      from
        ProcessWithParentSummary limit {}
     ) as a
        group by a.parent_path, a.parent_command_line, a.process_path,
          a.process_command_line, a.user_name, a.group_name
        having cnt &gt; {}
        order by cnt
  ) as b&quot;&quot;&quot;.format(str(getlines), str(sql_count_limit))

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })


    for line in response.splitlines():
        line = line.encode(&#x27;ascii&#x27;, errors=&#x27;backslashreplace&#x27;).decode()
        tanium.results.add(&quot;{}&quot;.format(line))

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
            <sensor_query>
                <sensor_type>8</sensor_type>
                <os>2</os>
                <query>#!&#x2F;bin&#x2F;bash
# -*- coding: utf-8 -*-
&quot;exec&quot; &quot;env&quot; &quot;TANIUM_SENSOR=1&quot; &quot;`pwd`&#x2F;python27&#x2F;python&quot; &quot;$0&quot; &quot;$@&quot;

&quot;&quot;&quot;Implements the recorder.query mbox command.&quot;&quot;&quot;

import traceback
import json
import sys

try:
    from threat_response import tanium_cx
except:
    pass

import tanium.sensor_io.sensor_input
from tanium_cx.core import mailbox

def is_recorder_disabled():
    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;core.get-extensions&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;json&#x27;,
        },
    }, {
        &#x27;wait_secs&#x27;: 5,
    })

    extensions = json.loads(response)

    for extension in extensions:
        if &#x27;recorder&#x27; in extension[&#x27;domain&#x27;]:
            return False

    # recorder isn&#x27;t running, so return whether or not the disable flag is set
    return tanium.get_config(&quot;DisableExtension_recorder&quot;)

def main():
    &quot;&quot;&quot; First make sure recorder is running &quot;&quot;&quot;
    if is_recorder_disabled():
        tanium.results.add(&quot;Recorder extension is disabled&quot;)
        return False

    &quot;&quot;&quot; set values, run query, report results &quot;&quot;&quot;
    timeout = 60
    getlines = 10000
    percent = 3
    sql_count_limit = getlines * float(percent) &#x2F; 100

    &quot;&quot;&quot; Get first X lines, grouping them and showing ones over y% &quot;&quot;&quot;
    query = &quot;&quot;&quot;
select b.parent_path,
  replace(replace(replace(b.parent_command_line,&#x27;|&#x27;,&#x27;_PIPE_&#x27;),char(13),&#x27;_NEWLINE_&#x27;),char(10),&#x27;_NEWLINE_&#x27;),
  b.process_path,
  replace(replace(replace(b.process_command_line,&#x27;|&#x27;,&#x27;_PIPE_&#x27;),char(13),&#x27;_NEWLINE_&#x27;),char(10),&#x27;_NEWLINE_&#x27;),
  b.user_name, b.group_name
from
  (select count(*) as cnt, a.parent_path, a.parent_command_line,
     a.process_path, a.process_command_line, a.user_name, a.group_name
   from
     (select parent_path, parent_command_line,
        process_path, process_command_line, user_name, group_name
      from
        ProcessWithParentSummary limit {}
     ) as a
        group by a.parent_path, a.parent_command_line, a.process_path,
          a.process_command_line, a.user_name, a.group_name
        having cnt &gt; {}
        order by cnt
  ) as b&quot;&quot;&quot;.format(str(getlines), str(sql_count_limit))

    mbox = mailbox.Mailbox()
    response = mbox.write_and_read({
        &#x27;command_name&#x27;: &#x27;recorder.query&#x27;,
        &#x27;command_version&#x27;: 1,
        &#x27;payload&#x27;: {
            &#x27;format&#x27;: &#x27;sql&#x27;,
            &#x27;query&#x27;: query,
        }
    }, {
        &#x27;wait_secs&#x27;: timeout,
    })


    for line in response.splitlines():
        line = line.encode(&#x27;ascii&#x27;, errors=&#x27;backslashreplace&#x27;).decode()
        tanium.results.add(&quot;{}&quot;.format(line))

if __name__ == &#x27;__main__&#x27;:
    try:
        main()
    except Exception as e:
        tanium.results.add(&#x27;TSE-Error: &#x27; + traceback.format_exc().replace(&#x27;\n&#x27;, &#x27;-&gt;&#x27;))
        sys.stderr.write(&#x27;Caught Error: {}&#x27;.format(str(e)))
        traceback.print_exc()
        sys.exit(1)
</query>
                <signature></signature>
            </sensor_query>
        </queries>
        <columns>
            <column>
                <column_index>0</column_index>
                <name>Parent Path</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>1</column_index>
                <name>Parent Command Line</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>2</column_index>
                <name>Process Path</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>3</column_index>
                <name>Process Command Line</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>4</column_index>
                <name>User</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
            <column>
                <column_index>5</column_index>
                <name>Group</name>
                <hidden_flag>0</hidden_flag>
                <result_type>1</result_type>
                <ignore_case_flag>1</ignore_case_flag>
                <exclude_from_parse>1</exclude_from_parse>
            </column>
        </columns>
        <meta_data/>
        <content_set>
            <name>Tanium Recorder</name>
            <description>Content which interacts with the Tanium Recorder</description>
            <reserved_name>tanium-recorder</reserved_name>
            <meta_data/>
        </content_set>
    </sensor>
</content>